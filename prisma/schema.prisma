generator client {
  provider = "prisma-client"
  output   = "../src/generated/prisma"
}

datasource db {
  provider          = "mysql"
  url               = env("DATABASE_URL")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
}

model User {
  id                     Int            @id @default(autoincrement())
  email                  String         @unique
  name                   String
  passwordHash           String?
  phone                  String?
  jobTitle               String?
  company                String?
  avatarUrl              String?
  twoFactor              Boolean        @default(false)
  newsletter             Boolean        @default(false)
  phoneVerified          Boolean        @default(false)
  discordTag             String?        @unique
  pendingEmail           String?
  emailVerificationToken String?
  emailVerifiedAt        DateTime?
  createdAt              DateTime       @default(now())
  forms                  Form[]
  assignedTickets        Ticket[]       @relation("TicketAssignedTo")
  tickets                Ticket[]
  TicketUpdate           TicketUpdate[]
  documents              Document[]
  files                  File[]
  passwords              PasswordVault[]
  webhooks               Webhook[]
}

model Category {
  id          Int      @id @default(autoincrement())
  name        String   @unique
  description String?
  tickets     Ticket[]
}

model Ticket {
  id           Int             @id @default(autoincrement())
  title        String
  description  String?         @db.LongText
  status       TicketStatus    @default(OPEN)
  userId       Int
  categoryId   Int?
  submissionId Int?            @unique
  createdAt    DateTime        @default(now())
  updatedAt    DateTime        @updatedAt
  assignedToId Int?
  scheduledAt  DateTime?
  scheduledNote String?        @db.Text
  assignedTo   User?           @relation("TicketAssignedTo", fields: [assignedToId], references: [id])
  category     Category?       @relation(fields: [categoryId], references: [id])
  submission   FormSubmission? @relation(fields: [submissionId], references: [id])
  user         User            @relation(fields: [userId], references: [id])
  updates      TicketUpdate[]

  @@index([assignedToId], map: "Ticket_assignedToId_fkey")
  @@index([categoryId], map: "Ticket_categoryId_fkey")
  @@index([userId], map: "Ticket_userId_fkey")
}

model TicketUpdate {
  id        Int      @id @default(autoincrement())
  ticketId  Int
  userId    Int?
  content   String   @db.Text
  createdAt DateTime @default(now())

  ticket Ticket @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  user   User?  @relation(fields: [userId], references: [id])

  @@index([ticketId])
  @@index([userId])
}

model Form {
  id          Int              @id @default(autoincrement())
  title       String
  description String?
  slug        String           @unique
  isPublic    Boolean          @default(true)
  userId      Int
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
  user        User             @relation(fields: [userId], references: [id])
  fields      FormField[]
  submissions FormSubmission[]

  @@index([userId], map: "Form_userId_fkey")
}

model FormField {
  id       Int       @id @default(autoincrement())
  label    String
  type     FieldType
  options  String?
  required Boolean   @default(true)
  formId   Int
  form     Form      @relation(fields: [formId], references: [id])

  @@index([formId], map: "FormField_formId_fkey")
}

model FormSubmission {
  id        Int      @id @default(autoincrement())
  data      String   @db.LongText
  formId    Int
  createdAt DateTime @default(now())
  form      Form     @relation(fields: [formId], references: [id])
  ticket    Ticket?

  @@index([formId], map: "FormSubmission_formId_fkey")
}

enum TicketStatus {
  OPEN
  IN_PROGRESS
  OBSERVATION
  RESOLVED
  CLOSED
}

enum FieldType {
  TEXT
  TEXTAREA
  SELECT
  RADIO
  CHECKBOX
  FILE
}

model Document {
  id          Int      @id @default(autoincrement())
  title       String
  content     String   @db.LongText
  category    String?
  tags        String?
  createdById Int
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  createdBy   User     @relation(fields: [createdById], references: [id])

  @@index([createdById], map: "Document_createdById_fkey")
  @@index([category])
}

model File {
  id          Int      @id @default(autoincrement())
  name        String
  originalName String
  mimeType    String
  size        Int
  path        String
  category    String?
  tags        String?
  description String?  @db.Text
  createdById Int
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  createdBy   User     @relation(fields: [createdById], references: [id])

  @@index([createdById], map: "File_createdById_fkey")
  @@index([category])
  @@index([mimeType])
}

model PasswordVault {
  id          Int      @id @default(autoincrement())
  title       String
  username    String?  @db.Text
  password    String   @db.Text
  url         String?  @db.Text
  notes       String?  @db.Text
  category    String?
  tags        String?
  createdById Int
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  createdBy   User     @relation(fields: [createdById], references: [id])

  @@index([createdById], map: "PasswordVault_createdById_fkey")
  @@index([category])
}

model Webhook {
  id          Int      @id @default(autoincrement())
  name        String
  description String?
  token       String   @unique
  isActive    Boolean  @default(true)
  userId      Int
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  user        User     @relation(fields: [userId], references: [id])

  @@index([userId], map: "Webhook_userId_fkey")
  @@index([token])
}
