generator client {
  provider = "prisma-client"
  output   = "../src/generated/prisma"
}

datasource db {
  provider          = "postgresql"
  url               = env("DATABASE_URL")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
}

model User {
  id                     Int                 @id @default(autoincrement())
  email                  String              @unique
  name                   String
  passwordHash           String?
  phone                  String?
  jobTitle               String?
  company                String?
  avatarUrl              String?
  twoFactor              Boolean             @default(true)
  newsletter             Boolean             @default(false)
  phoneVerified          Boolean             @default(false)
  discordTag             String?             @unique
  pendingEmail           String?
  emailVerificationToken String?
  emailVerifiedAt        DateTime?
  passwordResetToken     String?
  passwordResetExpires   DateTime?
  twoFactorCode          String?
  twoFactorCodeExpires   DateTime?
  createdAt              DateTime            @default(now())
  forms                  Form[]
  formsToApprove         FormApprover[]
  assignedTickets        Ticket[]            @relation("TicketAssignedTo")
  tickets                Ticket[]
  TicketUpdate           TicketUpdate[]
  documents              Document[]
  files                  File[]
  passwords              PasswordVault[]
  webhooks               Webhook[]
  events                 Event[]
  formApprovals          FormApproval[]
  createdProjects        Project[]           @relation("ProjectCreator")
  projectMemberships     ProjectMember[]     @relation("ProjectMember")
  assignedTasks          ProjectTask[]       @relation("TaskAssignedTo")
  createdTasks           ProjectTask[]       @relation("TaskCreator")
  accessProfiles         UserAccessProfile[]
  chatFeedbacks          ChatFeedback[]
}

model Category {
  id          Int      @id @default(autoincrement())
  name        String   @unique
  description String?
  tickets     Ticket[]
}

model Ticket {
  id            Int             @id @default(autoincrement())
  title         String
  description   String?         @db.Text
  status        TicketStatus    @default(OPEN)
  userId        Int
  categoryId    Int?
  submissionId  Int?            @unique
  projectId     Int?
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt
  assignedToId  Int?
  scheduledAt   DateTime?
  scheduledNote String?         @db.Text
  assignedTo    User?           @relation("TicketAssignedTo", fields: [assignedToId], references: [id])
  category      Category?       @relation(fields: [categoryId], references: [id])
  submission    FormSubmission? @relation(fields: [submissionId], references: [id])
  user          User            @relation(fields: [userId], references: [id])
  project       Project?        @relation(fields: [projectId], references: [id])
  updates       TicketUpdate[]

  @@index([assignedToId], map: "Ticket_assignedToId_fkey")
  @@index([categoryId], map: "Ticket_categoryId_fkey")
  @@index([userId], map: "Ticket_userId_fkey")
  @@index([projectId])
}

model TicketUpdate {
  id        Int      @id @default(autoincrement())
  ticketId  Int
  userId    Int?
  content   String   @db.Text
  createdAt DateTime @default(now())

  ticket Ticket @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  user   User?  @relation(fields: [userId], references: [id])

  @@index([ticketId])
  @@index([userId])
}

model Form {
  id               Int              @id @default(autoincrement())
  title            String
  description      String?
  slug             String           @unique
  isPublic         Boolean          @default(true)
  requiresApproval Boolean          @default(false)
  userId           Int
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt
  user             User             @relation(fields: [userId], references: [id])
  approvers        FormApprover[]
  fields           FormField[]
  submissions      FormSubmission[]
  approvals        FormApproval[]

  @@index([userId], map: "Form_userId_fkey")
}

model FormField {
  id       Int       @id @default(autoincrement())
  label    String
  type     FieldType
  options  String?
  required Boolean   @default(true)
  formId   Int
  form     Form      @relation(fields: [formId], references: [id])

  @@index([formId], map: "FormField_formId_fkey")
}

model FormSubmission {
  id        Int           @id @default(autoincrement())
  data      String        @db.Text
  formId    Int
  createdAt DateTime      @default(now())
  form      Form          @relation(fields: [formId], references: [id])
  ticket    Ticket?
  approval  FormApproval?

  @@index([formId], map: "FormSubmission_formId_fkey")
}

model FormApprover {
  id        Int      @id @default(autoincrement())
  formId    Int
  userId    Int
  createdAt DateTime @default(now())
  form      Form     @relation(fields: [formId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([formId, userId])
  @@index([formId])
  @@index([userId])
}

model FormApproval {
  id           Int            @id @default(autoincrement())
  submissionId Int            @unique
  formId       Int
  status       ApprovalStatus @default(PENDING)
  reviewedById Int?
  reviewedAt   DateTime?
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt
  submission   FormSubmission @relation(fields: [submissionId], references: [id])
  form         Form           @relation(fields: [formId], references: [id])
  reviewedBy   User?          @relation(fields: [reviewedById], references: [id])

  @@index([formId])
  @@index([status])
  @@index([reviewedById])
}

enum ApprovalStatus {
  PENDING
  APPROVED
  REJECTED
}

enum TicketStatus {
  OPEN
  IN_PROGRESS
  OBSERVATION
  RESOLVED
  CLOSED
}

enum FieldType {
  TEXT
  TEXTAREA
  SELECT
  RADIO
  CHECKBOX
  FILE
}

model Document {
  id          Int      @id @default(autoincrement())
  title       String
  content     String   @db.Text
  category    String?
  tags        String?
  createdById Int
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  createdBy   User     @relation(fields: [createdById], references: [id])

  @@index([createdById], map: "Document_createdById_fkey")
  @@index([category])
}

model File {
  id           Int      @id @default(autoincrement())
  name         String
  originalName String
  mimeType     String
  size         Int
  path         String
  category     String?
  tags         String?
  description  String?  @db.Text
  createdById  Int
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  createdBy    User     @relation(fields: [createdById], references: [id])

  @@index([createdById], map: "File_createdById_fkey")
  @@index([category])
  @@index([mimeType])
}

model PasswordVault {
  id          Int      @id @default(autoincrement())
  title       String
  username    String?  @db.Text
  password    String   @db.Text
  url         String?  @db.Text
  notes       String?  @db.Text
  category    String?
  tags        String?
  createdById Int
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  createdBy   User     @relation(fields: [createdById], references: [id])

  @@index([createdById], map: "PasswordVault_createdById_fkey")
  @@index([category])
}

model Webhook {
  id          Int      @id @default(autoincrement())
  name        String
  description String?
  token       String   @unique
  isActive    Boolean  @default(true)
  userId      Int
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  user        User     @relation(fields: [userId], references: [id])

  @@index([userId], map: "Webhook_userId_fkey")
  @@index([token])
}

model Event {
  id          Int      @id @default(autoincrement())
  title       String
  description String?  @db.Text
  startDate   DateTime
  endDate     DateTime
  location    String?
  color       String?  @default("#3b82f6")
  isAllDay    Boolean  @default(false)
  userId      Int
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  user        User     @relation(fields: [userId], references: [id])

  @@index([userId], map: "Event_userId_fkey")
  @@index([startDate])
  @@index([endDate])
}

model Project {
  id          Int             @id @default(autoincrement())
  name        String
  description String?         @db.Text
  status      ProjectStatus   @default(PLANNING)
  progress    Int             @default(0)
  startDate   DateTime?
  endDate     DateTime?
  color       String?         @default("#3b82f6")
  createdById Int
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt
  createdBy   User            @relation("ProjectCreator", fields: [createdById], references: [id])
  members     ProjectMember[]
  tickets     Ticket[]
  tasks       ProjectTask[]

  @@index([createdById])
  @@index([status])
  @@index([startDate])
  @@index([endDate])
}

model ProjectMember {
  id        Int      @id @default(autoincrement())
  projectId Int
  userId    Int
  role      String   @default("MEMBER")
  createdAt DateTime @default(now())
  project   Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)
  user      User     @relation("ProjectMember", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([projectId, userId])
  @@index([projectId])
  @@index([userId])
}

model ProjectTask {
  id           Int           @id @default(autoincrement())
  projectId    Int
  title        String
  description  String?       @db.Text
  status       TaskStatus    @default(TODO)
  priority     TaskPriority  @default(MEDIUM)
  dueDate      DateTime?
  assignedToId Int?
  createdById  Int
  parentTaskId Int?
  order        Int           @default(0)
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  project      Project       @relation(fields: [projectId], references: [id], onDelete: Cascade)
  assignedTo   User?         @relation("TaskAssignedTo", fields: [assignedToId], references: [id])
  createdBy    User          @relation("TaskCreator", fields: [createdById], references: [id])
  parentTask   ProjectTask?  @relation("TaskHierarchy", fields: [parentTaskId], references: [id], onDelete: Cascade)
  subtasks     ProjectTask[] @relation("TaskHierarchy")

  @@index([projectId])
  @@index([assignedToId])
  @@index([createdById])
  @@index([parentTaskId])
  @@index([status])
  @@index([priority])
  @@index([dueDate])
}

enum ProjectStatus {
  PLANNING
  IN_PROGRESS
  ON_HOLD
  COMPLETED
  CANCELLED
}

enum TaskStatus {
  TODO
  IN_PROGRESS
  DONE
  CANCELLED
}

enum TaskPriority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

model AccessProfile {
  id          Int                 @id @default(autoincrement())
  name        String
  description String?             @db.Text
  isDefault   Boolean             @default(false)
  createdAt   DateTime            @default(now())
  updatedAt   DateTime            @updatedAt
  pages       AccessProfilePage[]
  users       UserAccessProfile[]
}

model AccessProfilePage {
  id        Int           @id @default(autoincrement())
  profileId Int
  pagePath  String
  pageName  String
  profile   AccessProfile @relation(fields: [profileId], references: [id], onDelete: Cascade)

  @@unique([profileId, pagePath])
  @@index([profileId])
}

model UserAccessProfile {
  id        Int           @id @default(autoincrement())
  userId    Int
  profileId Int
  createdAt DateTime      @default(now())
  user      User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  profile   AccessProfile @relation(fields: [profileId], references: [id], onDelete: Cascade)

  @@unique([userId, profileId])
  @@index([userId])
  @@index([profileId])
}

model ChatFeedback {
  id        Int      @id @default(autoincrement())
  userId    Int
  messageId String // ID da mensagem no chat (gerado no frontend)
  isHelpful Boolean // true = útil, false = não útil
  comment   String?  @db.Text
  intent    String?
  source    String? // local-ai, rule-based, cache
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([messageId])
  @@index([isHelpful])
  @@index([createdAt])
}
